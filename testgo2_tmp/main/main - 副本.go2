package main

import (
	"fmt"
	"sync"
	"time"
)

type ImageData struct {
	i int32
	s string
}

func (c ImageData) String() string {
	if c.i ==1 {
		return "aaaa"
	} else {
		return c.s[0:1] + "..."
	}

}

func Addx[T int | string | float32](a,b T) T {
	return a+b
}

type M[K string, V any] map[K] V

type Z struct {
	i int
	j int
}

func main() {
	ic := ImageData{i:100, s:"bbb"}
	fmt.Printf("sss: %s\n", ic)

	m2 := M[string, Z] {"kkk": {20, 22}}
	tv := m2["kkk"]
	fmt.Printf("m2: %+v\n", tv)

	c:=Addx(10, 202)
	fmt.Printf("%v", c)

    var wg sync.WaitGroup
    var count int
    var ch = make(chan bool, 1)

    for i:=0; i<=1000; i++ {
    	wg.Add(1)
    	go func() {
    		ch <- true
    		count++
    		time.Sleep(1 * time.Millisecond)
    		count--
    		<-ch
    		wg.Done()
		}()
	}
	wg.Wait()
    fmt.Println(count)
}

func lastNumsBySlice(origin string) string {
	return origin[6:]
}

func dosomething(millisecs time.Duration, wg *sync.WaitGroup) {
	//
	duration := millisecs * time.Millisecond
	time.Sleep(duration) // sleep一段时间

	fmt.Printf("sleep duration:%v\n", duration)
	wg.Done()
}

/*
import (
	"github.com/tidwall/pretty"
	"net/http"

	"github.com/gin-gonic/gin"
)

func main() {

	router := gin.Default()

	ssjson := "{\"name\":  {\"first\":\"Tom\",\"last\":\"Anderson\"},  \"age\":37,\n\"children\": [\"Sara\",\"Alex\",\"Jack\"],\n\"fav.movie\": \"Deer Hunter\", \"friends\": [\n    {\"first\": \"Janet\", \"last\": \"Murphy\", \"age\": 44}\n  ]}"
	s := pretty.Pretty([]byte(ssjson))
	router.GET("/", func(c *gin.Context) {
		c.String( http.StatusOK, string(s))
	})

	router.Run("127.0.0.1:8080")
}
*/


/*package main

import (
	"context"
	"crypto/ecdsa"
	"fmt"
	"log"
	"math/big"

	ethereum "github.com/ethereum/go-ethereum"
	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/common/hexutil"
	"github.com/ethereum/go-ethereum/core/types"
	"github.com/ethereum/go-ethereum/crypto"
	"github.com/ethereum/go-ethereum/ethclient"
	"golang.org/x/crypto/sha3"
)

func main() {
	client, err := ethclient.Dial("https://rinkeby.infura.io")
	if err != nil {
		log.Fatal(err)
	}

	privateKey, err := crypto.HexToECDSA("fad9c8855b740a0b7ed4c221dbad0f33a83a49cad6b3fe8d5817ac83d38b6a19")
	if err != nil {
		log.Fatal(err)
	}

	publicKey := privateKey.Public()
	publicKeyECDSA, ok := publicKey.(*ecdsa.PublicKey)
	if !ok {
		log.Fatal("cannot assert type: publicKey is not of type *ecdsa.PublicKey")
	}

	fromAddress := crypto.PubkeyToAddress(*publicKeyECDSA)
	nonce, err := client.PendingNonceAt(context.Background(), fromAddress)
	if err != nil {
		log.Fatal(err)
	}

	value := big.NewInt(0) // in wei (0 eth)
	gasPrice, err := client.SuggestGasPrice(context.Background())
	if err != nil {
		log.Fatal(err)
	}

	toAddress := common.HexToAddress("0x4592d8f8d7b001e72cb26a73e4fa1806a51ac79d")
	tokenAddress := common.HexToAddress("0x28b149020d2152179873ec60bed6bf7cd705775d")

	transferFnSignature := []byte("transfer(address,uint256)")
	hash := sha3.NewLegacyKeccak256()
	hash.Write(transferFnSignature)
	methodID := hash.Sum(nil)[:4]
	fmt.Println(hexutil.Encode(methodID)) // 0xa9059cbb

	paddedAddress := common.LeftPadBytes(toAddress.Bytes(), 32)
	fmt.Println(hexutil.Encode(paddedAddress)) // 0x0000000000000000000000004592d8f8d7b001e72cb26a73e4fa1806a51ac79d

	amount := new(big.Int)
	amount.SetString("1000000000000000000000", 10) // sets the value to 1000 tokens, in the token denomination

	paddedAmount := common.LeftPadBytes(amount.Bytes(), 32)
	fmt.Println(hexutil.Encode(paddedAmount)) // 0x00000000000000000000000000000000000000000000003635c9adc5dea00000

	var data []byte
	data = append(data, methodID...)
	data = append(data, paddedAddress...)
	data = append(data, paddedAmount...)

	gasLimit, err := client.EstimateGas(context.Background(), ethereum.CallMsg{
		To:   &tokenAddress,
		Data: data,
	})
	if err != nil {
		log.Fatal(err)
	}
	fmt.Println(gasLimit) // 23256

	tx := types.NewTransaction(nonce, tokenAddress, value, gasLimit, gasPrice, data)

	chainID, err := client.NetworkID(context.Background())
	if err != nil {
		log.Fatal(err)
	}

	signedTx, err := types.SignTx(tx, types.NewEIP155Signer(chainID), privateKey)
	if err != nil {
		log.Fatal(err)
	}

	err = client.SendTransaction(context.Background(), signedTx)
	if err != nil {
		log.Fatal(err)
	}

	fmt.Printf("tx sent: %s", signedTx.Hash().Hex()) // tx sent: 0xa56316b637a94c4cc0331c73ef26389d6c097506d581073f927275e7a6ece0bc
}
 */